<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Magical Smooth Scroll Experience</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Outfit:wght@300;400;500&display=swap" rel="stylesheet">
  
  <!-- Lenis Smooth Scroll Library -->
  <script src="https://cdn.jsdelivr.net/gh/studio-freight/lenis@1.0.29/bundled/lenis.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --color-bg-deep: #0a0a0f;
      --color-bg-dark: #12121a;
      --color-bg-card: #1a1a25;
      --color-primary: #7b5cff;
      --color-primary-glow: #9d85ff;
      --color-accent: #00f5d4;
      --color-accent-2: #ff6b9d;
      --color-text: #e8e6f0;
      --color-text-muted: #8a879c;
    }

    html.lenis {
      height: auto;
    }

    .lenis.lenis-smooth {
      scroll-behavior: auto !important;
    }

    .lenis.lenis-smooth [data-lenis-prevent] {
      overscroll-behavior: contain;
    }

    .lenis.lenis-stopped {
      overflow: hidden;
    }

    .lenis.lenis-scrolling iframe {
      pointer-events: none;
    }

    body {
      font-family: 'Outfit', -apple-system, sans-serif;
      background: var(--color-bg-deep);
      color: var(--color-text);
      overflow-x: hidden;
    }

    /* Particle Canvas */
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 1;
    }

    /* Fire Canvas */
    #fireCanvas {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 300px;
      pointer-events: none;
      z-index: 3;
      opacity: 1;
    }


    /* Background Pattern */
    .bg-pattern {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.15;
      z-index: 0;
      background-image: 
        radial-gradient(circle at 2px 2px, rgba(123, 92, 255, 0.4) 1px, transparent 0),
        radial-gradient(circle at 25px 25px, rgba(0, 245, 212, 0.2) 1px, transparent 0);
      background-size: 50px 50px, 100px 100px;
      will-change: transform;
    }

    /* Starfield Background */
    .starfield {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      opacity: 0.6;
      will-change: transform, opacity;
    }

    /* Sparkles */
    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
      will-change: transform, opacity;
    }

    /* Lightning Effect */
    .lightning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.3);
      pointer-events: none;
      z-index: 5;
      opacity: 0;
    }

    /* Fire Section Background */
    .fire-section {
      position: relative;
      background: 
        linear-gradient(to bottom, var(--color-bg-deep) 0%, #1a0a0a 50%, #0a0a0a 100%),
        radial-gradient(ellipse at bottom, rgba(255, 100, 0, 0.2) 0%, transparent 70%);
      min-height: 100vh;
      padding: 6rem 2rem;
      z-index: 2;
    }


    /* Hero Section */
    .hero {
      position: relative;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      z-index: 2;
    }

    .hero-bg {
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(123, 92, 255, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(0, 245, 212, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(255, 107, 157, 0.2) 0%, transparent 70%);
      will-change: transform;
      animation: gradientShift 20s ease infinite;
    }

    @keyframes gradientShift {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      33% { transform: translate(-5%, -5%) rotate(5deg); }
      66% { transform: translate(5%, 5%) rotate(-5deg); }
    }

    .hero-content {
      position: relative;
      z-index: 3;
      text-align: center;
      padding: 2rem;
    }

    .hero h1 {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(3rem, 8vw, 7rem);
      font-weight: 700;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--color-text) 0%, var(--color-primary-glow) 30%, var(--color-accent) 60%, var(--color-accent-2) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      will-change: transform;
      filter: drop-shadow(0 0 30px rgba(123, 92, 255, 0.5));
      animation: textGlow 3s ease-in-out infinite alternate;
    }

    @keyframes textGlow {
      from { filter: drop-shadow(0 0 30px rgba(123, 92, 255, 0.5)); }
      to { filter: drop-shadow(0 0 50px rgba(0, 245, 212, 0.7)); }
    }

    .hero p {
      font-size: 1.5rem;
      color: var(--color-text-muted);
      max-width: 600px;
      margin: 0 auto;
      will-change: transform;
    }

    /* Morphing Shapes */
    .morph-shape {
      position: absolute;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
      opacity: 0.15;
      will-change: transform, border-radius;
      filter: blur(40px);
    }

    .morph-1 {
      width: 400px;
      height: 400px;
      top: 10%;
      left: 5%;
      animation: morph1 8s ease-in-out infinite;
    }

    .morph-2 {
      width: 300px;
      height: 300px;
      bottom: 15%;
      right: 10%;
      animation: morph2 10s ease-in-out infinite;
    }

    .morph-3 {
      width: 250px;
      height: 250px;
      top: 50%;
      left: 50%;
      animation: morph3 12s ease-in-out infinite;
    }

    @keyframes morph1 {
      0%, 100% { transform: translate(0, 0) scale(1); border-radius: 50% 40% 60% 30%; }
      25% { transform: translate(30px, -20px) scale(1.1); border-radius: 60% 30% 50% 40%; }
      50% { transform: translate(-20px, 30px) scale(0.9); border-radius: 40% 60% 30% 50%; }
      75% { transform: translate(20px, 20px) scale(1.05); border-radius: 50% 30% 60% 40%; }
    }

    @keyframes morph2 {
      0%, 100% { transform: translate(0, 0) scale(1); border-radius: 40% 60% 50% 30%; }
      33% { transform: translate(-40px, 20px) scale(1.15); border-radius: 60% 40% 30% 50%; }
      66% { transform: translate(20px, -30px) scale(0.85); border-radius: 30% 50% 60% 40%; }
    }

    @keyframes morph3 {
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); border-radius: 50%; }
      50% { transform: translate(-45%, -55%) scale(1.2) rotate(180deg); border-radius: 30% 70% 50% 50%; }
    }

    /* Section Styles */
    .section {
      min-height: 100vh;
      padding: 6rem 2rem;
      position: relative;
      z-index: 2;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .section-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(2.5rem, 5vw, 4.5rem);
      margin-bottom: 3rem;
      text-align: center;
      color: var(--color-text);
      position: relative;
    }

    .section-title::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--color-primary), var(--color-accent), transparent);
      animation: lineGlow 2s ease-in-out infinite;
    }

    @keyframes lineGlow {
      0%, 100% { opacity: 0.5; width: 100px; }
      50% { opacity: 1; width: 150px; }
    }

    /* Tree Section */
    .tree-section {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: linear-gradient(to bottom, var(--color-bg-deep) 0%, rgba(18, 18, 26, 0.8) 50%, var(--color-bg-deep) 100%);
    }

    .tree-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      height: 100vh;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }

    .tree-svg {
      width: 100%;
      height: 90%;
      max-height: 800px;
    }

    .tree-branch {
      transform-origin: center bottom;
      will-change: transform;
    }

    .tree-leaf {
      transform-origin: center;
      will-change: transform;
    }

    /* Parallax Cards */
    .parallax-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 2rem;
      margin-top: 4rem;
    }

    .parallax-card {
      background: var(--color-bg-card);
      border-radius: 20px;
      padding: 2.5rem;
      border: 1px solid rgba(123, 92, 255, 0.2);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform;
      position: relative;
      overflow: hidden;
    }

    .parallax-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(123, 92, 255, 0.1), transparent);
      transition: left 0.6s ease;
    }

    .parallax-card:hover::before {
      left: 100%;
    }

    .parallax-card:hover {
      transform: translateY(-10px) scale(1.02);
      box-shadow: 0 30px 60px rgba(123, 92, 255, 0.4), 0 0 40px rgba(0, 245, 212, 0.2);
      border-color: var(--color-primary);
    }

    .parallax-card h3 {
      font-family: 'Cormorant Garamond', serif;
      font-size: 2rem;
      margin-bottom: 1rem;
      color: var(--color-primary-glow);
      position: relative;
      z-index: 1;
    }

    .parallax-card p {
      color: var(--color-text-muted);
      line-height: 1.8;
      position: relative;
      z-index: 1;
    }

    /* Floating Particles Section */
    .particles-section {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .particle-field {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, var(--color-primary) 0%, transparent 70%);
      opacity: 0.6;
      will-change: transform;
    }

    /* Scroll Progress */
    .scroll-progress {
      position: fixed;
      top: 0;
      left: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--color-primary), var(--color-accent), var(--color-accent-2));
      z-index: 1000;
      transform-origin: left;
      will-change: transform;
      box-shadow: 0 0 10px rgba(123, 92, 255, 0.8);
    }

    /* Zoom Text Section */
    .zoom-section {
      position: relative;
      min-height: 300vh; /* Extended height - more scroll space for zoom effect */
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .zoom-content {
      position: sticky;
      top: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .zoom-text {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, var(--color-text) 0%, var(--color-primary-glow) 50%, var(--color-accent) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transform-origin: center;
      will-change: transform;
      transition: none;
      white-space: nowrap;
    }

    /* Sticky Section */
    .sticky-section {
      position: relative;
      min-height: 300vh;
    }

    .sticky-content {
      position: sticky;
      top: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .sticky-item {
      position: absolute;
      width: 100%;
      text-align: center;
      opacity: 0;
      transform: scale(0.5) rotateY(90deg);
      transition: none;
    }


    .sticky-item h2 {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(3rem, 6vw, 6rem);
      margin-bottom: 2rem;
      background: linear-gradient(135deg, var(--color-primary-glow), var(--color-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Text Reveal */
    .text-reveal {
      opacity: 0;
      transform: translateY(80px) scale(0.9);
      transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .text-reveal.revealed {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    /* Glow Orbs */
    .glow-orb {
      position: absolute;
      border-radius: 50%;
      filter: blur(60px);
      opacity: 0.3;
      will-change: transform;
    }

    .orb-1 {
      width: 500px;
      height: 500px;
      background: var(--color-primary);
      top: 20%;
      left: 10%;
      animation: orbFloat1 20s ease-in-out infinite;
    }

    .orb-2 {
      width: 400px;
      height: 400px;
      background: var(--color-accent);
      bottom: 20%;
      right: 15%;
      animation: orbFloat2 25s ease-in-out infinite;
    }

    @keyframes orbFloat1 {
      0%, 100% { transform: translate(0, 0) scale(1); }
      33% { transform: translate(100px, -50px) scale(1.2); }
      66% { transform: translate(-50px, 100px) scale(0.8); }
    }

    @keyframes orbFloat2 {
      0%, 100% { transform: translate(0, 0) scale(1); }
      50% { transform: translate(-80px, 80px) scale(1.3); }
    }

    /* Footer */
    .footer {
      padding: 4rem 2rem;
      text-align: center;
      background: var(--color-bg-dark);
      border-top: 1px solid rgba(123, 92, 255, 0.2);
      position: relative;
      z-index: 2;
    }

    .footer p {
      color: var(--color-text-muted);
      margin-bottom: 1rem;
    }

    .footer a {
      color: var(--color-primary-glow);
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .footer a:hover {
      color: var(--color-accent);
    }
  </style>
</head>
<body>
  <!-- Background Pattern -->
  <div class="bg-pattern" id="bgPattern"></div>

  <!-- Starfield -->
  <div class="starfield" id="starfield"></div>

  <!-- Particle Canvas -->
  <canvas id="particleCanvas"></canvas>

  <!-- Fire Canvas -->
  <canvas id="fireCanvas"></canvas>

  <!-- Lightning Effect -->
  <div class="lightning" id="lightning"></div>

  <!-- Scroll Progress Bar -->
  <div class="scroll-progress" id="scrollProgress"></div>

  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-bg" data-speed="0.5"></div>
    <div class="morph-shape morph-1"></div>
    <div class="morph-shape morph-2"></div>
    <div class="morph-shape morph-3"></div>
    <div class="hero-content">
      <h1 data-speed="0.3">Magical Scroll</h1>
      <p data-speed="0.2">Particles, Trees & Infinite Possibilities</p>
    </div>
  </section>

  <!-- Tree Section -->
  <section class="tree-section">
    <div class="glow-orb orb-1"></div>
    <div class="glow-orb orb-2"></div>
    <div class="tree-container">
      <svg class="tree-svg" viewBox="0 0 400 600" xmlns="http://www.w3.org/2000/svg">
        <!-- Trunk -->
        <path d="M 200 550 L 200 400 L 210 400 L 210 550 Z" fill="#8B4513" class="tree-trunk" data-speed="0.1"/>
        
        <!-- Main Branches -->
        <g class="tree-branch" data-speed="0.15">
          <path d="M 200 400 L 150 350 L 160 340 L 200 390 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
          <path d="M 200 400 L 250 350 L 240 340 L 200 390 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
        </g>
        
        <g class="tree-branch" data-speed="0.2">
          <path d="M 200 380 L 130 320 L 140 310 L 200 370 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
          <path d="M 200 380 L 270 320 L 260 310 L 200 370 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
        </g>
        
        <g class="tree-branch" data-speed="0.25">
          <path d="M 200 360 L 110 280 L 120 270 L 200 350 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
          <path d="M 200 360 L 290 280 L 280 270 L 200 350 Z" fill="#654321" stroke="#8B4513" stroke-width="2"/>
        </g>
        
        <!-- Leaves -->
        <circle cx="150" cy="340" r="25" fill="#2d5016" class="tree-leaf" data-speed="0.3"/>
        <circle cx="250" cy="340" r="28" fill="#2d5016" class="tree-leaf" data-speed="0.35"/>
        <circle cx="130" cy="310" r="30" fill="#2d5016" class="tree-leaf" data-speed="0.4"/>
        <circle cx="270" cy="310" r="27" fill="#2d5016" class="tree-leaf" data-speed="0.3"/>
        <circle cx="110" cy="270" r="32" fill="#2d5016" class="tree-leaf" data-speed="0.45"/>
        <circle cx="290" cy="270" r="29" fill="#2d5016" class="tree-leaf" data-speed="0.35"/>
        <circle cx="200" cy="250" r="35" fill="#2d5016" class="tree-leaf" data-speed="0.4"/>
        <circle cx="170" cy="280" r="24" fill="#2d5016" class="tree-leaf" data-speed="0.3"/>
        <circle cx="230" cy="280" r="26" fill="#2d5016" class="tree-leaf" data-speed="0.4"/>
        <circle cx="180" cy="300" r="22" fill="#2d5016" class="tree-leaf" data-speed="0.35"/>
        <circle cx="220" cy="300" r="23" fill="#2d5016" class="tree-leaf" data-speed="0.3"/>
      </svg>
    </div>
  </section>

  <!-- Features Section -->
  <section class="section">
    <div class="container">
      <h2 class="section-title">Scroll Magic Unleashed</h2>
      <div class="parallax-cards">
        <div class="parallax-card" data-speed="0.1">
          <h3>âœ¨ Particle Systems</h3>
          <p>Thousands of particles flowing and reacting to your scroll. Each particle moves independently, creating mesmerizing visual effects that respond to your movement.</p>
        </div>
        <div class="parallax-card" data-speed="0.15">
          <h3>ðŸŒ³ Living Trees</h3>
          <p>Animated trees with branches that sway and leaves that flutter in the wind. Each element moves at different speeds, creating depth and life.</p>
        </div>
        <div class="parallax-card" data-speed="0.2">
          <h3>ðŸŒ€ Morphing Shapes</h3>
          <p>Organic shapes that continuously transform, creating fluid, dreamlike backgrounds that shift and flow as you explore.</p>
        </div>
        <div class="parallax-card" data-speed="0.1">
          <h3>ðŸ’« Glow Orbs</h3>
          <p>Floating orbs of light that drift through the scene, adding atmosphere and depth with their soft, ethereal glow.</p>
        </div>
        <div class="parallax-card" data-speed="0.15">
          <h3>ðŸŽ­ 3D Transforms</h3>
          <p>Elements that rotate and transform in 3D space as you scroll, creating immersive depth and perspective changes.</p>
        </div>
        <div class="parallax-card" data-speed="0.2">
          <h3>ðŸŒˆ Gradient Magic</h3>
          <p>Dynamic gradients that shift and evolve, creating living color palettes that respond to scroll position and time.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Particles Section -->
  <section class="particles-section">
    <div class="particle-field" id="particleField"></div>
    <div class="container" style="position: relative; z-index: 2;">
      <h2 class="section-title">Floating Particles</h2>
      <div class="text-reveal" style="max-width: 800px; margin: 0 auto; text-align: center;">
        <p style="font-size: 1.25rem; line-height: 1.8; color: var(--color-text-muted);">
          Watch as particles float and dance around you. Each one follows its own path, creating a dynamic, ever-changing landscape that responds to your scroll.
        </p>
      </div>
    </div>
  </section>

  <!-- Fire Section -->
  <section class="fire-section">
    <div class="container" style="position: relative; z-index: 2;">
      <h2 class="section-title">ðŸ”¥ Fire Effects</h2>
      <div class="text-reveal" style="max-width: 800px; margin: 0 auto; text-align: center;">
        <p style="font-size: 1.25rem; line-height: 1.8; color: var(--color-text-muted);">
          Scroll to see dynamic fire effects at the bottom. The flames dance and flicker, creating an immersive atmosphere that responds to your movement.
        </p>
      </div>
    </div>
  </section>

  <!-- Zoom Text Section -->
  <section class="zoom-section" id="zoomSection">
    <div class="zoom-content">
      <h1 class="zoom-text" id="zoomText">zoom till very end</h1>
    </div>
  </section>

  <!-- Sticky Section -->
  <section class="sticky-section">
    <div class="sticky-content">
      <div class="sticky-item active" data-index="0">
        <h2>Infinite Scroll</h2>
        <p style="font-size: 1.5rem; color: var(--color-text-muted);">Content that transforms as you journey through</p>
      </div>
      <div class="sticky-item" data-index="1">
        <h2>Dynamic States</h2>
        <p style="font-size: 1.5rem; color: var(--color-text-muted);">Each scroll position reveals new magic</p>
      </div>
      <div class="sticky-item" data-index="2">
        <h2>Seamless Flow</h2>
        <p style="font-size: 1.5rem; color: var(--color-text-muted);">Smooth transitions between every state</p>
      </div>
    </div>
  </section>

  <!-- Text Reveal Section -->
  <section class="section">
    <div class="container">
      <h2 class="section-title">Scroll-Triggered Magic</h2>
      <div class="text-reveal" style="max-width: 800px; margin: 0 auto; text-align: center;">
        <p style="font-size: 1.25rem; line-height: 1.8; color: var(--color-text-muted); margin-bottom: 2rem;">
          Every element comes alive as it enters your view. Particles swirl, trees sway, shapes morph, and colors shift. This is scroll-based animation at its finest.
        </p>
        <p style="font-size: 1.25rem; line-height: 1.8; color: var(--color-text-muted);">
          Combine smooth scrolling with particle systems, animated nature, morphing shapes, and dynamic lighting for an experience that feels truly magical.
        </p>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <p>âœ¨ Built with Lenis Smooth Scroll & Pure Magic âœ¨</p>
    <p>
      <a href="https://github.com/studio-freight/lenis" target="_blank">Lenis</a> | 
      <a href="https://greensock.com/scrolltrigger/" target="_blank">GSAP ScrollTrigger</a> | 
      <a href="https://locomotivemtl.github.io/locomotive-scroll/" target="_blank">Locomotive Scroll</a>
    </p>
  </footer>

  <script>
    // Initialize Lenis Smooth Scroll
    const lenis = new Lenis({
      duration: 1.2,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      orientation: 'vertical',
      gestureOrientation: 'vertical',
      smoothWheel: true,
      wheelMultiplier: 1,
      smoothTouch: false,
      touchMultiplier: 2,
      infinite: false,
    });

    // Animation frame loop
    function raf(time) {
      lenis.raf(time);
      requestAnimationFrame(raf);
    }
    requestAnimationFrame(raf);

    // Particle System
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    const particleCount = 200;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    class Particle {
      constructor() {
        this.reset();
        this.baseY = Math.random() * canvas.height;
        this.baseX = Math.random() * canvas.width;
      }

      reset() {
        this.baseX = Math.random() * canvas.width;
        this.baseY = Math.random() * canvas.height;
        this.size = Math.random() * 4 + 2;
        this.opacity = Math.random() * 0.7 + 0.5;
        this.color = Math.random() > 0.5 ? 'rgba(123, 92, 255, ' : 'rgba(0, 245, 212, ';
        this.offsetX = (Math.random() - 0.5) * 200;
        this.offsetY = (Math.random() - 0.5) * 200;
        this.speed = Math.random() * 0.5 + 0.3;
      }

      update(scrollProgress, scrollVelocity) {
        // Base position from scroll
        const scrollOffset = scrollProgress * 0.3;
        
        // Calculate position based on scroll with some offset for visual interest
        this.x = this.baseX + Math.sin(scrollProgress * this.speed * 0.01) * this.offsetX;
        this.y = this.baseY + scrollOffset + Math.cos(scrollProgress * this.speed * 0.01) * this.offsetY;
        
        // Add velocity-based movement for more dynamic feel
        const velocityEffect = scrollVelocity * 0.1;
        this.x += velocityEffect;
        this.y += velocityEffect * 0.5;

        // Wrap around edges
        if (this.x < -50) this.x = canvas.width + 50;
        if (this.x > canvas.width + 50) this.x = -50;
        if (this.y < -50) {
          this.y = canvas.height + 50;
          this.baseY = canvas.height + 50;
        }
        if (this.y > canvas.height + 50) {
          this.y = -50;
          this.baseY = -50;
        }
      }

      draw() {
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color.replace('rgba', 'rgba').replace(')', ', 1)');
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color + this.opacity + ')';
        ctx.fill();
        
        ctx.shadowBlur = 0;
      }
    }

    // Initialize particles
    for (let i = 0; i < particleCount; i++) {
      particles.push(new Particle());
    }

    let scrollProgress = 0;
    let scrollVelocity = 0;
    let lastScroll = 0;
    
    function animateParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Calculate velocity
      scrollVelocity = scrollProgress - lastScroll;
      lastScroll = scrollProgress;
      
      particles.forEach(particle => {
        particle.update(scrollProgress, scrollVelocity);
        particle.draw();
      });

      // Connect nearby particles with brighter lines
      particles.forEach((p1, i) => {
        particles.slice(i + 1).forEach(p2 => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 120) {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(123, 92, 255, ${0.3 * (1 - distance / 120)})`;
            ctx.lineWidth = 1;
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        });
      });

      requestAnimationFrame(animateParticles);
    }
    animateParticles();

    // Scroll progress indicator and update scroll values
    lenis.on('scroll', ({ scroll, limit, velocity, direction, progress }) => {
      scrollProgress = scroll;
      scrollVelocity = velocity;
      const progressBar = document.getElementById('scrollProgress');
      if (progressBar) {
        progressBar.style.transform = `scaleX(${progress})`;
      }
    });

    // Parallax effects
    lenis.on('scroll', ({ scroll }) => {
      // Hero background
      const heroBg = document.querySelector('.hero-bg');
      if (heroBg) {
        const speed = parseFloat(heroBg.dataset.speed) || 0.5;
        heroBg.style.transform = `translateY(${scroll * speed}px) rotate(${scroll * 0.05}deg)`;
      }

      // Hero content
      const heroContent = document.querySelector('.hero-content h1');
      if (heroContent) {
        const speed = parseFloat(heroContent.dataset.speed) || 0.3;
        heroContent.style.transform = `translateY(${scroll * speed}px) scale(${1 + scroll * 0.0001})`;
      }

      const heroP = document.querySelector('.hero-content p');
      if (heroP) {
        const speed = parseFloat(heroP.dataset.speed) || 0.2;
        heroP.style.transform = `translateY(${scroll * speed}px)`;
      }

      // Tree elements - scroll-driven animation
      document.querySelectorAll('.tree-branch, .tree-leaf, .tree-trunk').forEach(el => {
        const rect = el.closest('.tree-section').getBoundingClientRect();
        const speed = parseFloat(el.dataset.speed) || 0.1;
        const offset = (window.innerHeight - rect.top) * speed;
        
        // Scroll-based rotation for leaves (more pronounced)
        let rotation = 0;
        if (el.classList.contains('tree-leaf')) {
          rotation = Math.sin(scroll * 0.002) * 5 + Math.cos(scroll * 0.0015) * 3;
        } else if (el.classList.contains('tree-branch')) {
          rotation = Math.sin(scroll * 0.001) * 2;
        }
        
        el.style.transform = `translateY(${offset}px) rotate(${rotation}deg)`;
      });

      // Parallax cards
      document.querySelectorAll('.parallax-card').forEach(card => {
        const rect = card.getBoundingClientRect();
        const speed = parseFloat(card.dataset.speed) || 0.1;
        const offset = (window.innerHeight - rect.top) * speed;
        const rotation = Math.sin(scroll * 0.0005) * 1;
        card.style.transform = `translateY(${offset}px) rotate(${rotation}deg)`;
      });

      // Morph shapes
      document.querySelectorAll('.morph-shape').forEach((shape, index) => {
        const speed = 0.3 + index * 0.1;
        shape.style.transform += ` translateY(${scroll * speed * 0.1}px)`;
      });
    });

    // Text reveal on scroll
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -100px 0px'
    };

    const revealObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('revealed');
        }
      });
    }, observerOptions);

    document.querySelectorAll('.text-reveal').forEach(el => {
      revealObserver.observe(el);
    });

    // Zoom text effect - consumes scroll to zoom text
    const zoomSection = document.getElementById('zoomSection');
    const zoomText = document.getElementById('zoomText');
    let zoomScrollStart = 0;
    let zoomScrollEnd = 0;
    let isZooming = false;
    let accumulatedZoom = 0;

    if (zoomSection) {
      // Calculate zoom section bounds
      function updateZoomBounds() {
        zoomScrollStart = zoomSection.offsetTop - window.innerHeight;
        zoomScrollEnd = zoomSection.offsetTop + zoomSection.offsetHeight - window.innerHeight;
      }
      updateZoomBounds();
      window.addEventListener('resize', updateZoomBounds);

      lenis.on('scroll', ({ scroll, limit, velocity, direction }) => {
        updateZoomBounds();
        
        // Check if we're in the zoom section
        const isInZoomSection = scroll >= zoomScrollStart && scroll <= zoomScrollEnd;
        
        if (isInZoomSection) {
          isZooming = true;
          
          // Calculate progress through zoom section (0 to 1)
          const sectionHeight = zoomScrollEnd - zoomScrollStart;
          const scrollInSection = scroll - zoomScrollStart;
          const zoomProgress = Math.max(0, Math.min(1, scrollInSection / sectionHeight));
          
          // Scale from 1 to 25 (very big) - exponential curve for more dramatic effect
          const minScale = 1;
          const maxScale = 25;
          // Use ease-out curve for smoother zoom
          const easedProgress = 1 - Math.pow(1 - zoomProgress, 3);
          const scale = minScale + (easedProgress * (maxScale - minScale));
          
          // Apply zoom transform
          zoomText.style.transform = `scale(${scale})`;
          
          // Add some opacity fade as it gets very large (fade out near the end)
          const opacity = zoomProgress > 0.85 ? Math.max(0, 1 - (zoomProgress - 0.85) * 6.67) : 1;
          zoomText.style.opacity = opacity;
          
        } else {
          if (isZooming && scroll > zoomScrollEnd) {
            // Reset zoom when leaving section
            zoomText.style.transform = 'scale(1)';
            zoomText.style.opacity = '1';
            isZooming = false;
          } else if (scroll < zoomScrollStart) {
            // Reset if scrolling back up
            zoomText.style.transform = 'scale(1)';
            zoomText.style.opacity = '1';
            isZooming = false;
          }
        }
      });
    }

    // Sticky section state changes
    const stickySection = document.querySelector('.sticky-section');
    const stickyItems = document.querySelectorAll('.sticky-item');
    
    if (stickySection) {
      lenis.on('scroll', ({ scroll }) => {
        const rect = stickySection.getBoundingClientRect();
        const sectionTop = stickySection.offsetTop;
        const sectionHeight = stickySection.offsetHeight;
        const viewportHeight = window.innerHeight;
        
        const scrollProgress = Math.max(0, Math.min(1, (scroll - sectionTop + viewportHeight) / sectionHeight));
        
        stickyItems.forEach((item, index) => {
          const itemProgress = (scrollProgress * stickyItems.length) - index;
          
          // Remove all active classes first
          stickyItems.forEach(i => i.classList.remove('active'));
          
          if (itemProgress >= 0 && itemProgress < 1) {
            item.classList.add('active');
            const opacity = Math.max(0, Math.min(1, 1 - itemProgress));
            const scale = 0.5 + (opacity * 0.5);
            const rotation = (1 - opacity) * 90;
            
            // Direct style application - no transitions
            item.style.opacity = opacity;
            item.style.transform = `scale(${scale}) rotateY(${rotation}deg)`;
          } else if (itemProgress >= 1) {
            item.style.opacity = 0;
            item.style.transform = 'scale(0.5) rotateY(90deg)';
          } else {
            item.style.opacity = 0;
            item.style.transform = 'scale(0.5) rotateY(-90deg)';
          }
        });
      });
    }

    // Create floating particles in particle field - scroll-driven
    const particleField = document.getElementById('particleField');
    const fieldParticles = [];
    for (let i = 0; i < 30; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.width = Math.random() * 8 + 4 + 'px';
      particle.style.height = particle.style.width;
      const baseLeft = Math.random() * 100;
      const baseTop = Math.random() * 100;
      particle.style.left = baseLeft + '%';
      particle.style.top = baseTop + '%';
      particle.dataset.baseLeft = baseLeft;
      particle.dataset.baseTop = baseTop;
      particle.dataset.speed = Math.random() * 0.3 + 0.2;
      particleField.appendChild(particle);
      fieldParticles.push(particle);
    }
    
    // Update field particles based on scroll
    lenis.on('scroll', ({ scroll }) => {
      fieldParticles.forEach((particle, index) => {
        const baseLeft = parseFloat(particle.dataset.baseLeft);
        const baseTop = parseFloat(particle.dataset.baseTop);
        const speed = parseFloat(particle.dataset.speed);
        const offsetX = Math.sin(scroll * speed * 0.01 + index) * 50;
        const offsetY = scroll * 0.1 + Math.cos(scroll * speed * 0.01 + index) * 30;
        particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      });
    });

    // Fire Effect System
    const fireCanvas = document.getElementById('fireCanvas');
    const fireCtx = fireCanvas.getContext('2d');
    let fireParticles = [];
    const fireParticleCount = 80;

    function resizeFireCanvas() {
      fireCanvas.width = window.innerWidth;
      fireCanvas.height = 300;
    }
    resizeFireCanvas();
    window.addEventListener('resize', resizeFireCanvas);

    class FireParticle {
      constructor() {
        this.x = Math.random() * fireCanvas.width;
        this.y = fireCanvas.height;
        this.size = Math.random() * 20 + 10;
        this.speed = Math.random() * 3 + 1;
        this.life = 1;
        this.decay = Math.random() * 0.02 + 0.01;
        this.hue = Math.random() * 30 + 10; // Orange to red
        this.brightness = Math.random() * 20 + 50; // Brighter fire
      }

      update(scrollProgress) {
        this.y -= this.speed + Math.sin(scrollProgress * 0.01) * 0.5;
        this.x += (Math.random() - 0.5) * 2;
        this.life -= this.decay;
        this.size *= 0.98;
      }

      draw() {
        if (this.life <= 0) {
          this.reset();
        }
        const gradient = fireCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.life})`);
        gradient.addColorStop(0.5, `hsla(${this.hue + 10}, 100%, ${this.brightness - 10}%, ${this.life * 0.7})`);
        gradient.addColorStop(1, `hsla(${this.hue + 20}, 100%, ${this.brightness - 20}%, 0)`);
        
        fireCtx.fillStyle = gradient;
        fireCtx.beginPath();
        fireCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        fireCtx.fill();
      }

      reset() {
        this.x = Math.random() * fireCanvas.width;
        this.y = fireCanvas.height;
        this.life = 1;
        this.size = Math.random() * 25 + 15;
        this.brightness = Math.random() * 20 + 50;
      }
    }

    for (let i = 0; i < fireParticleCount; i++) {
      fireParticles.push(new FireParticle());
    }

    function animateFire() {
      // Clear with slight fade for trail effect
      fireCtx.fillStyle = 'rgba(10, 10, 15, 0.3)';
      fireCtx.fillRect(0, 0, fireCanvas.width, fireCanvas.height);
      
      fireParticles.forEach(particle => {
        particle.update(scrollProgress);
        particle.draw();
      });

      requestAnimationFrame(animateFire);
    }
    animateFire();

    // Control fire visibility based on scroll position
    lenis.on('scroll', ({ scroll }) => {
      const fireSection = document.querySelector('.fire-section');
      if (fireSection) {
        const rect = fireSection.getBoundingClientRect();
        const isInView = rect.top < window.innerHeight && rect.bottom > 0;
        const fireCanvasEl = document.getElementById('fireCanvas');
        if (fireCanvasEl) {
          // Show fire more prominently when fire section is in view
          if (isInView) {
            fireCanvasEl.style.opacity = '1';
          } else if (scroll > fireSection.offsetTop + fireSection.offsetHeight) {
            // Fade out after fire section
            fireCanvasEl.style.opacity = '0.5';
          } else {
            fireCanvasEl.style.opacity = '0.3';
          }
        }
      }
    });

    // Sparkles System
    function createSparkles() {
      const sections = document.querySelectorAll('.section, .hero, .tree-section');
      sections.forEach(section => {
        for (let i = 0; i < 10; i++) {
          const sparkle = document.createElement('div');
          sparkle.className = 'sparkle';
          sparkle.style.left = Math.random() * 100 + '%';
          sparkle.style.top = Math.random() * 100 + '%';
          section.appendChild(sparkle);
        }
      });
    }
    createSparkles();

    // Update sparkles based on scroll
    lenis.on('scroll', ({ scroll }) => {
      document.querySelectorAll('.sparkle').forEach((sparkle, index) => {
        const rect = sparkle.closest('section, .hero, .tree-section')?.getBoundingClientRect();
        if (rect) {
          const offsetX = Math.sin(scroll * 0.01 + index) * 20;
          const offsetY = Math.cos(scroll * 0.01 + index) * 20;
          sparkle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
          sparkle.style.opacity = Math.sin(scroll * 0.005 + index) * 0.5 + 0.5;
        }
      });
    });

    // Lightning Effect
    function triggerLightning() {
      const lightning = document.getElementById('lightning');
      lightning.style.opacity = '1';
      setTimeout(() => {
        lightning.style.opacity = '0';
      }, 100);
    }

    // Trigger lightning on scroll milestones
    let lastLightningScroll = 0;
    lenis.on('scroll', ({ scroll }) => {
      if (scroll - lastLightningScroll > 1000) {
        if (Math.random() > 0.7) {
          triggerLightning();
        }
        lastLightningScroll = scroll;
      }
    });

    // Background pattern parallax
    lenis.on('scroll', ({ scroll }) => {
      const bgPattern = document.getElementById('bgPattern');
      if (bgPattern) {
        bgPattern.style.transform = `translate(${scroll * 0.1}px, ${scroll * 0.05}px)`;
      }
    });

    // Starfield Creation
    const starfield = document.getElementById('starfield');
    const stars = [];
    for (let i = 0; i < 200; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 100 + '%';
      star.style.width = Math.random() * 2 + 1 + 'px';
      star.style.height = star.style.width;
      star.style.opacity = Math.random() * 0.5 + 0.3;
      star.dataset.speed = Math.random() * 0.5 + 0.1;
      starfield.appendChild(star);
      stars.push(star);
    }

    // Animate stars based on scroll
    lenis.on('scroll', ({ scroll }) => {
      stars.forEach((star, index) => {
        const speed = parseFloat(star.dataset.speed);
        const offsetX = Math.sin(scroll * speed * 0.001 + index) * 10;
        const offsetY = scroll * speed * 0.05 + Math.cos(scroll * speed * 0.001 + index) * 5;
        star.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        star.style.opacity = Math.sin(scroll * speed * 0.002 + index) * 0.3 + 0.4;
      });
    });

  </script>
</body>
</html>
